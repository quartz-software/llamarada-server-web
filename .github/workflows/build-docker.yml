name: Flujo de Publicacion del Proyecto
on:
  push:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U test -d testdb"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    outputs:
      test_status: ${{ job.status }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install dependencies
        run: npm install

      - name: Crear archivo .env.test
        run: |
          cat <<EOF > .env.test
          NODE_ENV=test
          DB_NAME=${{secrets.DB_NAME_TEST}}
          DB_USER=${{secrets.DB_USER_TEST}}
          DB_PASS=${{secrets.DB_PASS_TEST}}
          DB_HOST=${{secrets.DB_HOST_TEST}}
          DB_PORT=${{secrets.DB_PORT_TEST}}
          DB_SSL=false
          SECRET=${{secrets.SECRET}}
          EOF

      - name: Run migration
        run: npm run migrate

      - name: Run tests
        run: npm run test

  terraform:
    needs: test
    if: needs.test.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      public_ip: ${{ steps.final_ip.outputs.public_ip }}
      terraform_status: ${{ job.status }}
    steps:
      - name: Guardar clave privada en runner
        run: |
          mkdir -p ~/.oci
          echo "${{ secrets.TF_PRIVATE_KEY }}" | tr -d '\r' > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem

          cat <<EOF > ~/.oci/config
          [DEFAULT]
          user=${{ secrets.TF_USER_OCID }}
          fingerprint=${{ secrets.TF_FINGERPRINT }}
          key_file=/home/runner/.oci/oci_api_key.pem
          tenancy=${{ secrets.TF_TENANCY_OCID }}
          region=${{ secrets.TF_REGION }}
          EOF
          chmod 600 ~/.oci/config

      - name: Instalar OCI CLI
        run: |
          bash -c "$(curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh)" -- --accept-all-defaults
          echo "$HOME/bin" >> $GITHUB_PATH

      - name: Obtener IP de instancia activa
        id: check_vm
        run: |
          INSTANCE_ID=$(oci compute instance list \
            --compartment-id ${{ secrets.TF_COMPARTMENT_OCID }} \
            --query "data[?\"display-name\"=='hotel-llamarada' && \"lifecycle-state\"=='RUNNING'].id | [0]" \
            --raw-output || echo "")

          if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "null" ]; then
              VNIC_ID=$(oci compute vnic-attachment list \
                --compartment-id ${{ secrets.TF_COMPARTMENT_OCID }} \
                --instance-id $INSTANCE_ID \
                --query "data[0].\"vnic-id\"" \
                --raw-output || echo "")

              PUBLIC_IP=$(oci network vnic get \
                --vnic-id $VNIC_ID \
                --query "data.\"public-ip\"" \
                --raw-output || echo "")

              echo "IP pública encontrada: $PUBLIC_IP"
              echo "instance_exists=true" >> $GITHUB_OUTPUT
              echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          else
              echo "instance_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Terraform
        if: steps.check_vm.outputs.instance_exists == 'false'
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.7.0
          terraform_wrapper: false

      - name: Crear terraform.tfvars
        if: steps.check_vm.outputs.instance_exists == 'false'
        working-directory: terraform
        run: |
          cat <<EOF > terraform.tfvars
          tenancy_ocid = "${{ secrets.TF_TENANCY_OCID }}"
          user_ocid = "${{ secrets.TF_USER_OCID }}"
          fingerprint = "${{ secrets.TF_FINGERPRINT }}"
          private_key_path = "~/.oci/oci_api_key.pem"
          region = "${{ secrets.TF_REGION }}"
          compartment_ocid = "${{ secrets.TF_COMPARTMENT_OCID }}"
          subnet_id = "${{ secrets.TF_SUBNET_ID }}"
          availability_domain = "${{ secrets.TF_AVAILABILITY_DOMAIN }}"
          ubuntu_image = "${{ secrets.TF_UBUNTU_IMAGE }}"
          ssh_public_key = "${{ secrets.TF_SSH_PUBLIC_KEY }}"
          EOF

      - name: Terraform Init & Apply
        if: steps.check_vm.outputs.instance_exists == 'false'
        id: terraform
        working-directory: terraform
        run: |
          terraform init
          terraform apply -auto-approve

      - name: Esperar que el servidor esté listo
        if: steps.check_vm.outputs.instance_exists == 'false'
        run: sleep 30

      - name: Definir IP final
        id: final_ip
        working-directory: terraform
        run: |
          if [ "${{ steps.check_vm.outputs.instance_exists }}" = "true" ]; then
            echo "public_ip=${{ steps.check_vm.outputs.public_ip }}" >> $GITHUB_OUTPUT
          else
            IP=$(terraform output -raw public_ip)
            echo "public_ip=$IP" >> $GITHUB_OUTPUT
          fi

      - name: Configurar SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{secrets.SSH_PRIVATE_KEY}}

      - name: Copiar y ejecutar setup_vm.sh
        uses: appleboy/scp-action@v0.1.3
        with:
          host: ${{ steps.final_ip.outputs.public_ip }}
          username: ${{secrets.SSH_USER}}
          key: ${{secrets.SSH_PRIVATE_KEY}}
          source: setup_vm.sh
          target: /tmp/

      - name: Ejecutar setup_vm.sh
        uses: appleboy/ssh-action@master
        with:
          host: ${{ steps.final_ip.outputs.public_ip }}
          username: ${{secrets.SSH_USER}}
          key: ${{secrets.SSH_PRIVATE_KEY}}
          script: |
            chmod +x /tmp/setup_vm.sh
            /tmp/setup_vm.sh ${{secrets.SSH_USER}}
            rm /tmp/setup_vm.sh

  docker:
    needs: [test, terraform]
    if: needs.test.result == 'success' && needs.terraform.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      docker_status: ${{ job.status }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Login DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{secrets.DOCKER_USER}}
          password: ${{secrets.DOCKER_TOKEN}}

      - name: Construir Imagen
        run: docker build -t ${{secrets.DOCKER_USER}}/hotel-llamarada:latest .

      - name: Publicar Imagen
        run: docker push ${{secrets.DOCKER_USER}}/hotel-llamarada:latest

  setup-vm:
    needs: [terraform, docker]
    if: needs.docker.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      setup_vm_status: ${{ job.status }}
    steps:
      - name: Copiar docker-compose.yml
        uses: appleboy/scp-action@v0.1.3
        with:
          host: ${{ needs.terraform.outputs.public_ip }}
          username: ${{secrets.SSH_USER}}
          key: ${{secrets.SSH_PRIVATE_KEY}}
          source: docker-compose.yml
          target: '/home/${{secrets.SSH_USER}}/deploy/'

      - name: Crear archivo .env remoto
        uses: appleboy/ssh-action@master
        with:
          host: ${{ needs.terraform.outputs.public_ip }}
          username: ${{secrets.SSH_USER}}
          key: ${{secrets.SSH_PRIVATE_KEY}}
          script: |
            mkdir -p /home/${{secrets.SSH_USER}}/deploy
            cat <<EOF > /home/${{secrets.SSH_USER}}/deploy/.env
            NODE_ENV=prod
            DB_NAME=${{secrets.DB_NAME}}
            DB_USER=${{secrets.DB_USER}}
            DB_PASS=${{secrets.DB_PASS}}
            DB_HOST=${{secrets.DB_HOST}}
            DB_PORT=${{secrets.DB_PORT}}
            DB_SSL=${{secrets.DB_SSL}}
            SECRET=${{secrets.SECRET}}
            EOF

      - name: Ejecutar Docker Compose
        uses: appleboy/ssh-action@master
        with:
          host: ${{ needs.terraform.outputs.public_ip }}
          username: ${{secrets.SSH_USER}}
          key: ${{secrets.SSH_PRIVATE_KEY}}
          script: |
            cd /home/${{secrets.SSH_USER}}/deploy
            echo ${{secrets.DOCKER_TOKEN}} | docker login -u ${{secrets.DOCKER_USER}} --password-stdin
            docker compose down
            docker compose pull
            docker compose up -d --force-recreate
            docker logout

      - name: Verificar base de datos y ejecutar migraciones si es necesario
        uses: appleboy/ssh-action@master
        with:
          host: ${{ needs.terraform.outputs.public_ip }}
          username: ${{secrets.SSH_USER}}
          key: ${{secrets.SSH_PRIVATE_KEY}}
          script: |
            cd /home/${{secrets.SSH_USER}}/deploy
            source .env

            TABLE_EXISTS=$(PGPASSWORD=$DB_PASS psql -h $DB_HOST -U $DB_USER -d $DB_NAME -tAc "SELECT to_regclass('public.habitacion');")

            if [ "$TABLE_EXISTS" = "null" ] || [ -z "$TABLE_EXISTS" ]; then
              echo "Tabla 'habitacion' no encontrada. Ejecutando migraciones y seed..."
              docker compose run --rm api npm run migrate:prod
              docker compose run --rm api npm run seed:prod
            else
              echo "Tabla 'habitacion' encontrada. No se ejecutan migraciones."
            fi

  notify:
    needs: [test, terraform, docker, setup-vm]
    runs-on: ubuntu-latest
    steps:
      - name: Enviar correo con IP
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.EMAIL_USER }}
          password: ${{ secrets.EMAIL_PASS }}
          from: ${{ secrets.EMAIL_USER }}
          to: joelalejsanchez@gmail.com
          subject: 'Resultado del despliegue de servidor web'
          body: |
            Estado test:       ${{ needs.test.result }}
            Estado terraform:  ${{ needs.terraform.result }}
            Estado docker:     ${{ needs.docker.result }}
            Estado setup-vm:   ${{ needs.setup-vm.result }}
            IP pública:        ${{ needs.terraform.outputs.public_ip }}
